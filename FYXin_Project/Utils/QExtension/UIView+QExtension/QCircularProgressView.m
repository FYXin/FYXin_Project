//
//  QCircularProgressView.m
//  QExtension
//
//  Created by JHQ0228 on 2017/4/3.
//  Copyright © 2017年 QianQian-Studio. All rights reserved.
//

#import "QCircularProgressView.h"

NS_ASSUME_NONNULL_BEGIN


#pragma mark - QCircularProgressView

@implementation QCircularProgressView

- (instancetype _Nullable)initWithCoder:(NSCoder *)coder {
    
    if (self = [super initWithCoder:coder]) {
        [self initView:[self frame]];
    }
    return self;
}

- (instancetype)init {
    
    if (self = [super init]) {
        [self initView:CGRectNull];
    }
    return self;
}

- (instancetype)initWithFrame:(CGRect)frame {
    
    if (self = [super initWithFrame:frame]) {
        [self initView:frame];
    }
    return self;
}

- (void)initView:(CGRect)frame {
    
    [self setContentScaleFactor:[UIScreen mainScreen].scale];
    
//    [self setProgressAngle:80.0f];
//    [self setProgressRotationAngle:0.0f];
//    
//    [self setShowValueString:YES];
//    [self setShowTargetValueString:YES];
//    [self setShowMarkValueString:YES];
//    [self setValue:0.0f];
//    [self setInsideValue:0.0f];
//    [self setOutsideValue:0.0f];
//    [self setMaxValue:1.0f];
//    [self setTargetValue:30];
//    [self setValueFontSize:-1];
//    [self setValueFontName:@"HelveticaNeue-Thin"];
//    [self setValueFontColor:[UIColor blackColor]];
//    [self setValueOffset:CGPointMake(0, 0)];
//    [self setShowValueDecimal:NO];
//    [self setValueDecimalPlaces:0];
//    [self setValueDecimalFontSize:-1];
//    [self setCountdown:NO];
//
//    [self setShowUnitString:NO];
//    [self setUnitString:@"%"];
//    [self setUnitFontSize:-1];
//    [self setUnitFontName:@"HelveticaNeue-Thin"];
//    [self setUnitFontColor:[UIColor blackColor]];
//    [self setUnitOffset:CGPointMake(0, 0)];
//    
//    [self setEmptyLineWidth:6.0f];
//    [self setEmptyLineColor:[UIColor colorWithRed:208/255.0 green:218/255.0 blue:218/255.0 alpha:1]];
//    [self setEmptyLineStrokeColor:[UIColor colorWithRed:88/255.0 green:89/255.0 blue:91/255.0 alpha:1]];
//    [self setEmptyLineCapType:kCGLineCapRound];
//    
//    [self setInsideLineWidth:10.0f];
//    [self setInsideLineColor:[UIColor colorWithRed:55/255.0 green:146/255.0 blue:207/255.0 alpha:1]];
//    [self setInsideLineStrokeColor:[UIColor colorWithRed:55/255.0 green:146/255.0 blue:207/255.0 alpha:1]];
//    [self setInsideLineCapType:kCGLineCapRound];
//    
//    [self setOutsideLineWidth:14.0f];
//    [self setOutsideLineColor:[UIColor colorWithRed:245/255.0 green:175/255.0 blue:63/255.0 alpha:1]];
//    [self setOutsideLineStrokeColor:[UIColor colorWithRed:245/255.0 green:175/255.0 blue:63/255.0 alpha:1]];
//    [self setOutsideLineCapType:kCGLineCapRound];
}

#pragma mark CALayer

- (QCircularProgressLayer *)progressLayer {
    QCircularProgressLayer *layer = (QCircularProgressLayer *)self.layer;
    return layer;
}

+ (Class)layerClass {
    return [QCircularProgressLayer class];
}

#pragma mark safeCapType

- (CGLineCap)safeCapType:(NSInteger)type {
    if(kCGLineCapButt <= type && type <= kCGLineCapSquare){
        return (CGLineCap)type;
    }
    return kCGLineCapRound;
}

#pragma mark angle

- (void)setProgressAngle:(CGFloat)progressAngle {
    self.progressLayer.progressAngle = progressAngle;
}

- (CGFloat)progressAngle {
    return self.progressLayer.progressAngle;
}

- (void)setProgressRotationAngle:(CGFloat)progressRootationAngle {
    self.progressLayer.progressRotationAngle = progressRootationAngle;
}

- (CGFloat)progressRootationAngle {
    return self.progressLayer.progressRotationAngle;
}

#pragma mark value

- (void)setShowValueString:(BOOL)showValueString {
    self.progressLayer.showValueString = showValueString;
    [self.layer setNeedsDisplay];
}

- (BOOL)showValueString {
    return self.progressLayer.showValueString;
}

- (void)setShowTargetValueString:(BOOL)showTargetValueString {
    self.progressLayer.showTargetValueString = showTargetValueString;
    [self.layer setNeedsDisplay];
}

- (BOOL)showTargetValueString {
    return self.progressLayer.showTargetValueString;
}

- (void)setShowMarkValueString:(BOOL)showMarkValueString {
    self.progressLayer.showMarkValueString = showMarkValueString;
    [self.layer setNeedsDisplay];
}

- (BOOL)showMarkValueString {
    return self.progressLayer.showMarkValueString;
}

- (void)setValue:(CGFloat)value {
    self.progressLayer.value = value;
    
    // CALayer autogenerated setter using @dynamic doesn't refresh the layer when the value is 0
    if (value == 0) [self.layer setNeedsDisplay];
}

- (CGFloat)value {
    return self.progressLayer.value;
}

- (void)setInsideValue:(CGFloat)insideValue {
    self.progressLayer.insideValue = insideValue;
    if (insideValue == 0) [self.layer setNeedsDisplay];
}

- (CGFloat)insideValue {
    return self.progressLayer.insideValue;
}

- (void)setOutsideValue:(CGFloat)outsideValue {
    self.progressLayer.outsideValue = outsideValue;
    if (outsideValue == 0) [self.layer setNeedsDisplay];
}

- (CGFloat)outsideValue {
    return self.progressLayer.outsideValue;
}

- (void)setMaxValue:(CGFloat)maxValue {
    self.progressLayer.maxValue = maxValue;
    if (maxValue == 0) [self.layer setNeedsDisplay];
}

- (CGFloat)maxValue {
    return self.progressLayer.maxValue;
}

- (void)setTargetValue:(CGFloat)targetValue {
    self.progressLayer.targetValue = targetValue;
    if (targetValue == 0) [self.layer setNeedsDisplay];
}

- (CGFloat)targetValue {
    return self.progressLayer.targetValue;
}

- (void)setValueFontSize:(CGFloat)valueFontSize {
    self.progressLayer.valueFontSize = valueFontSize;
}

- (CGFloat)valueFontSize {
    return self.progressLayer.valueFontSize;
}

- (void)setValueFontName:(NSString *)valueFontName {
    self.progressLayer.valueFontName = valueFontName;
}

- (NSString *)valueFontName {
    return self.progressLayer.valueFontName;
}

- (void)setValueFontColor:(UIColor *)valueFontColor {
    self.progressLayer.valueFontColor = valueFontColor;
}

- (UIColor *)valueFontColor {
    return self.progressLayer.valueFontColor;
}

- (void)setValueOffset:(CGPoint)valueOffset {
    self.progressLayer.valueOffset = valueOffset;
}

- (CGPoint)valueOffset {
    return self.progressLayer.valueOffset;
}

- (void)setShowValueDecimal:(BOOL)showValueDecimal {
    self.progressLayer.showValueDecimal = showValueDecimal;
    [self.layer setNeedsDisplay];
}

- (BOOL)showValueDecimal {
    return self.progressLayer.showValueDecimal;
}

- (void)setValueDecimalPlaces:(NSInteger)valueDecimalPlaces {
    self.progressLayer.valueDecimalPlaces = valueDecimalPlaces;
}

- (NSInteger)valueDecimalPlaces {
    return self.progressLayer.valueDecimalPlaces;
}

- (void)setValueDecimalFontSize:(CGFloat)valueDecimalFontSize {
    self.progressLayer.valueDecimalFontSize = valueDecimalFontSize;
}

- (CGFloat)valueDecimalFontSize {
    return self.progressLayer.valueDecimalFontSize;
}

- (void)setCountdown:(BOOL)countdown {
    self.progressLayer.countdown = countdown;
}

- (BOOL)countdown {
    return self.progressLayer.countdown;
}

#pragma mark unit

- (void)setShowUnitString:(BOOL)showUnitString {
    self.progressLayer.showUnitString = showUnitString;
}

- (BOOL)showUnitString {
    return self.progressLayer.showUnitString;
}

- (void)setUnitString:(NSString *)unitString {
    self.progressLayer.unitString = unitString;
}

- (NSString*)unitString {
    return self.progressLayer.unitString;
}

- (void)setUnitFontSize:(CGFloat)unitFontSize {
    self.progressLayer.unitFontSize = unitFontSize;
}

- (CGFloat)unitFontSize {
    return self.progressLayer.unitFontSize;
}

- (void)setUnitFontName:(NSString *)unitFontName {
    self.progressLayer.unitFontName = unitFontName;
}

- (NSString *)unitFontName {
    return self.progressLayer.unitFontName;
}

- (void)setUnitFontColor:(UIColor *)unitFontColor {
    self.progressLayer.unitFontColor = unitFontColor;
}

- (UIColor *)unitFontColor {
    return self.progressLayer.unitFontColor;
}

- (void)setUnitOffset:(CGPoint)unitOffset {
    self.progressLayer.unitOffset = unitOffset;
}

- (CGPoint)unitOffset {
    return self.progressLayer.unitOffset;
}

#pragma mark empty

- (void)setEmptyLineWidth:(CGFloat)width {
    self.progressLayer.emptyLineWidth = width;
}

- (CGFloat)emptyLineWidth {
    return self.progressLayer.emptyLineWidth;
}

- (void)setEmptyLineColor:(UIColor *)emptyLineColor {
    self.progressLayer.emptyLineColor = emptyLineColor;
}

- (UIColor*)emptyLineColor {
    return self.progressLayer.emptyLineColor;
}

- (void)setEmptyLineStrokeColor:(UIColor *)emptyLineStrokeColor {
    self.progressLayer.emptyLineStrokeColor = emptyLineStrokeColor;
}

- (UIColor*)emptyLineStrokeColor {
    return self.progressLayer.emptyLineStrokeColor;
}

- (void)setEmptyLineCapType:(NSInteger)emptyLineCapType {
    self.progressLayer.emptyLineCapType = [self safeCapType:emptyLineCapType];
}

- (NSInteger)emptyLineCapType {
    return self.progressLayer.emptyLineCapType;
}

#pragma mark inside

- (void)setInsideLineWidth:(CGFloat)width {
    self.progressLayer.insideLineWidth = width;
}

- (CGFloat)insideLineWidth {
    return self.progressLayer.insideLineWidth;
}

- (void)setInsideLineColor:(UIColor *)insideLineColor {
    self.progressLayer.insideLineColor = insideLineColor;
}

- (UIColor*)insideLineColor {
    return self.progressLayer.insideLineColor;
}

- (void)setInsideLineStrokeColor:(UIColor *)insideLineStrokeColor {
    self.progressLayer.insideLineStrokeColor = insideLineStrokeColor;
}

- (UIColor*)insideLineStrokeColor {
    return self.progressLayer.insideLineStrokeColor;
}

- (void)setInsideLineCapType:(NSInteger)insideLineCapType {
    self.progressLayer.insideLineCapType = [self safeCapType:insideLineCapType];
}

- (NSInteger)insideLineCapType {
    return self.progressLayer.insideLineCapType;
}

#pragma mark outside

- (void)setOutsideLineWidth:(CGFloat)width {
    self.progressLayer.outsideLineWidth = width;
}

- (CGFloat)outsideLineWidth {
    return self.progressLayer.outsideLineWidth;
}

- (void)setOutsideLineColor:(UIColor *)outsideLineColor {
    self.progressLayer.outsideLineColor = outsideLineColor;
}

- (UIColor*)outsideLineColor{
    return self.progressLayer.outsideLineColor;
}

- (void)setOutsideLineStrokeColor:(UIColor *)outsideLineStrokeColor {
    self.progressLayer.outsideLineStrokeColor = outsideLineStrokeColor;
}

- (UIColor*)outsideLineStrokeColor {
    return self.progressLayer.outsideLineStrokeColor;
}

- (void)setOutsideLineCapType:(NSInteger)outsideLineCapType {
    self.progressLayer.outsideLineCapType = [self safeCapType:outsideLineCapType];
}

- (NSInteger)outsideLineCapType {
    return self.progressLayer.outsideLineCapType;
}

@end


/*******************************************************************************/

#pragma mark - QCircularProgressLayer


#define CENTER_X            (rectSize.width / 2)
#define CENTER_Y            (rectSize.height / 2)
#define STA_ANGLE           ( (self.progressAngle / 100.f) * M_PI - ((-self.progressRotationAngle / 100.f) * 2.f + 0.5) * M_PI)
#define END_ANGLE           (-(self.progressAngle / 100.f) * M_PI - ((-self.progressRotationAngle / 100.f) * 2.f + 0.5) * M_PI)

#define MARK_VALUE_WIDTH    (self.showMarkValueString ? 20 : 0)

@implementation QCircularProgressLayer

@dynamic progressAngle;
@dynamic progressRotationAngle;

@dynamic showValueString;
@dynamic showTargetValueString;
@dynamic showMarkValueString;
@dynamic value;
@dynamic insideValue;
@dynamic outsideValue;
@dynamic maxValue;
@dynamic targetValue;
@dynamic valueFontSize;
@dynamic valueFontName;
@dynamic valueFontColor;
@dynamic valueOffset;
@dynamic showValueDecimal;
@dynamic valueDecimalPlaces;
@dynamic valueDecimalFontSize;
@dynamic countdown;

@dynamic showUnitString;
@dynamic unitString;
@dynamic unitFontSize;
@dynamic unitFontName;
@dynamic unitFontColor;
@dynamic unitOffset;

@dynamic emptyLineWidth;
@dynamic emptyLineColor;
@dynamic emptyLineStrokeColor;
@dynamic emptyLineCapType;

@dynamic insideLineWidth;
@dynamic insideLineColor;
@dynamic insideLineStrokeColor;
@dynamic insideLineCapType;

@dynamic outsideLineWidth;
@dynamic outsideLineColor;
@dynamic outsideLineStrokeColor;
@dynamic outsideLineCapType;

#pragma mark Drawing

- (void)drawInContext:(CGContextRef) context {
    [super drawInContext:context];
    
//    #pragma mark test
//    
//    self.insideValue = 0.5;
//    self.outsideValue = 1.0;
    
    UIGraphicsPushContext(context);
    
    // 将原矩形的值变成整数类型返回
    CGSize size = CGRectIntegral(CGContextGetClipBoundingBox(context)).size;
    
    [self drawInsideProgressBar:size  context:context];
    [self drawOutsideProgressBar:size context:context];
    [self drawEmptyProgressBar:size   context:context];
    
    if (self.showValueString) {
        if (self.showValueDecimal) {
            [self drawText:size context:context];
        } else {
            [self drawValueString:size context:context];
        }
    }
    
    if (self.showTargetValueString) {
        [self drawTargetValue:size context:context];
    }
    
    if (self.showMarkValueString) {
        [self drawMarkVlaue:size context:context];
    }
    
    UIGraphicsPopContext();
}

#pragma mark Progress Bar

- (void)drawInsideProgressBar:(CGSize)rectSize context:(CGContextRef)context {
    
    if (self.insideLineWidth <= 0) return;
    
    CGFloat radius     = MIN(CENTER_X, CENTER_Y) - self.insideLineWidth - self.outsideLineWidth - MARK_VALUE_WIDTH;
    CGFloat startAngle = STA_ANGLE - (2.f * M_PI) * (self.progressAngle / 100.f) *
                                     (100.f - 100.f * self.insideValue / self.maxValue) / 100.f;
    CGFloat endAngle   = END_ANGLE;
    
    [self drawProgressBarWithContext:context
                           lineWidth:self.insideLineWidth
                           lineColor:self.insideLineColor
                     lineStrokeColor:self.insideLineStrokeColor
                         lineCapType:self.insideLineCapType
                             centerX:CENTER_X
                             centerY:CENTER_Y
                              radius:radius
                          startAngle:startAngle
                            endAngle:endAngle];
}

- (void)drawOutsideProgressBar:(CGSize)rectSize context:(CGContextRef)context {
    
    if (self.outsideLineWidth <= 0) return;
    
    CGFloat radius     = MIN(CENTER_X, CENTER_Y) - self.outsideLineWidth - MARK_VALUE_WIDTH;
    CGFloat startAngle = STA_ANGLE - (2.f * M_PI) * (self.progressAngle / 100.f) *
                                     (100.f - 100.f * self.outsideValue / self.maxValue) / 100.f;
    CGFloat endAngle   = END_ANGLE;
    
    [self drawProgressBarWithContext:context
                           lineWidth:self.outsideLineWidth
                           lineColor:self.outsideLineColor
                     lineStrokeColor:self.outsideLineStrokeColor
                         lineCapType:self.outsideLineCapType
                             centerX:CENTER_X
                             centerY:CENTER_Y
                              radius:radius
                          startAngle:startAngle
                            endAngle:endAngle];
}

- (void)drawEmptyProgressBar:(CGSize)rectSize context:(CGContextRef)context {
    
    if (self.emptyLineWidth <= 0) return;
    
    CGFloat radius     = MIN(CENTER_X, CENTER_Y) - self.emptyLineWidth - self.outsideLineWidth - MARK_VALUE_WIDTH;
    CGFloat startAngle = STA_ANGLE + (0.01622 - radius * 0.00006) * M_PI;
    CGFloat endAngle   = END_ANGLE - (0.01622 - radius * 0.00006) * M_PI;
    
    [self drawProgressBarWithContext:context
                           lineWidth:self.emptyLineWidth
                           lineColor:self.emptyLineColor
                     lineStrokeColor:self.emptyLineStrokeColor
                         lineCapType:self.emptyLineCapType
                             centerX:CENTER_X
                             centerY:CENTER_Y
                              radius:radius
                          startAngle:startAngle
                            endAngle:endAngle];
}

- (void)drawProgressBarWithContext:(CGContextRef)context
                         lineWidth:(CGFloat)lineWidth
                         lineColor:(UIColor *)lineColor
                   lineStrokeColor:(UIColor *)lineStrokeColor
                       lineCapType:(CGLineCap)lineCapType
                           centerX:(CGFloat)centerX
                           centerY:(CGFloat)centerY
                            radius:(CGFloat)radius
                        startAngle:(CGFloat)startAngle
                          endAngle:(CGFloat)endAngle {
    
    CGMutablePathRef arc = CGPathCreateMutable();
    CGPathAddArc(arc, NULL, centerX, centerY, radius, startAngle, endAngle, YES);
    
    CGPathRef strokedArc = CGPathCreateCopyByStrokingPath(arc, NULL, lineWidth, lineCapType, kCGLineJoinMiter, 10);
    CGContextAddPath(context, strokedArc);
    CGContextSetFillColorWithColor(context, lineColor.CGColor);
    CGContextSetStrokeColorWithColor(context, lineStrokeColor.CGColor);
    CGContextDrawPath(context, kCGPathFillStroke);
    
    CGPathRelease(arc);
    CGPathRelease(strokedArc);
}

#pragma mark center Value String

- (void)drawValueString:(CGSize)rectSize context:(CGContextRef)c {
    
    UIColor *valueFontColor = self.valueFontColor;
    
    CGFloat multiple;
    
    if (([UIScreen mainScreen].bounds.size.width == 320) && MARK_VALUE_WIDTH) {
        multiple = 10;
    } else if (([UIScreen mainScreen].bounds.size.width == 375) && MARK_VALUE_WIDTH) {
        multiple = 9;
    } else if (([UIScreen mainScreen].bounds.size.width == 414) && MARK_VALUE_WIDTH) {
        multiple = 8;
    } else {
        multiple = 8;
    }
    
    // value
    NSString *valueStr    = [NSString stringWithFormat:@"%02ld:%02ld", (long)self.value / 60, (long)self.value % 60];
    CGFloat valueFontSize = (self.valueFontSize == -1) ? rectSize.height / multiple : self.valueFontSize;
    CGPoint offset        = CGPointMake(0, 0);
    [self drawValue:valueStr fontSize:valueFontSize fontColor:valueFontColor rect:rectSize offset:offset];
    
    // description
    valueStr      = @"Elapsed Time";
    valueFontSize = (self.valueFontSize == -1) ? rectSize.height / (multiple * 2) : self.valueFontSize;
    offset        = CGPointMake(0, 1.3);
    [self drawValue:valueStr fontSize:valueFontSize fontColor:valueFontColor rect:rectSize offset:offset];
}

- (void)drawValue:(NSString *)valueStr
         fontSize:(CGFloat)fontSize
        fontColor:(UIColor *)fontColor
             rect:(CGSize)rectSize
           offset:(CGPoint)offset {
    
    NSMutableParagraphStyle *textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    textStyle.alignment = NSTextAlignmentCenter;
    
    NSDictionary *valueFontAttributes = @{NSFontAttributeName:[UIFont boldSystemFontOfSize:fontSize],
                                          NSForegroundColorAttributeName:fontColor,
                                          NSParagraphStyleAttributeName:textStyle};
    NSAttributedString *value = [[NSAttributedString alloc] initWithString:valueStr attributes:valueFontAttributes];
    
    NSMutableAttributedString *text = [NSMutableAttributedString new];
    [text appendAttributedString:value];
    CGSize percentSize = [text size];
    CGPoint textCenter = CGPointMake(
                                     rectSize.width / 2 - percentSize.width / 2 + self.valueOffset.x,
                                     rectSize.height / 2 - percentSize.height / 2 + self.valueOffset.y + percentSize.height * offset.y
                                    );
    [text drawAtPoint:textCenter];
}

#pragma mark Target Value

- (void)drawTargetValue:(CGSize)rectSize context:(CGContextRef)c {
    
    UIColor *valueFontColor = self.valueFontColor;
    CGFloat valueFontSize = (self.valueFontSize == -1) ? rectSize.height / 14 : self.valueFontSize;
    
    // start Value
    NSString *valueStr = @"0  ";
    CGPoint offset     = CGPointMake(1, 0);
    [self drawTargetValue:valueStr fontSize:valueFontSize fontColor:valueFontColor rect:rectSize offset:offset];
    
    // target Value
    if (self.targetValue < 100) {
        valueStr  = [NSString stringWithFormat:@" %ld", (long)self.targetValue];
    } else {
        valueStr  = [NSString stringWithFormat:@"%ld", (long)self.targetValue];
    }
    offset        = CGPointMake(-1, 1);
    [self drawTargetValue:valueStr fontSize:valueFontSize fontColor:valueFontColor rect:rectSize offset:offset];
}

- (void)drawTargetValue:(NSString *)valueStr
               fontSize:(CGFloat)fontSize
              fontColor:(UIColor *)fontColor
                   rect:(CGSize)rectSize
                 offset:(CGPoint)offset {
    
    NSMutableParagraphStyle *textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    textStyle.alignment = NSTextAlignmentCenter;
    
    NSDictionary *valueFontAttributes = @{NSFontAttributeName:[UIFont boldSystemFontOfSize:fontSize],
                                          NSForegroundColorAttributeName:fontColor,
                                          NSParagraphStyleAttributeName:textStyle
                                        };
    NSAttributedString *value = [[NSAttributedString alloc] initWithString:valueStr attributes:valueFontAttributes];
    
    NSMutableAttributedString *text = [NSMutableAttributedString new];
    [text appendAttributedString:value];
    
    CGSize percentSize = [text size];
    CGFloat radius = MIN(CENTER_X, CENTER_Y) - MARK_VALUE_WIDTH;
    
    CGFloat multipleX =  0.00111111 * radius + 0.35333343;
    CGFloat multipleY = -0.00444444 * radius + 0.78666588;
    
    CGPoint textCenter = CGPointMake(
                                     CENTER_X - radius * sin(self.progressAngle / 2) * offset.x * multipleX - percentSize.width * offset.y,
                                     CENTER_Y - radius * cos(self.progressAngle / 2) - percentSize.height * multipleY
                                    );
    [text drawAtPoint:textCenter];
}

#pragma mark Mark Vlaue

- (void)drawMarkVlaue:(CGSize)rectSize context:(CGContextRef)context {
    
    if (self.emptyLineWidth <= 0) return;
    
    CGFloat radius = MIN(CENTER_X, CENTER_Y) - self.emptyLineWidth - self.outsideLineWidth - MARK_VALUE_WIDTH;
    
    CGFloat start = CENTER_X - radius - self.emptyLineWidth * 0.5;
    CGFloat end   = CENTER_X - radius - self.emptyLineWidth * 0.5 - self.outsideLineWidth;
    [self drawMarkVlaueWithStartX:start endX:end startY:CENTER_Y endY:CENTER_Y position:@"left"];
    
    start = CENTER_X + radius + self.emptyLineWidth * 0.5;
    end   = CENTER_X + radius + self.emptyLineWidth * 0.5 + self.outsideLineWidth;
    [self drawMarkVlaueWithStartX:start endX:end startY:CENTER_Y endY:CENTER_Y position:@"right"];
    
    start = CENTER_Y - radius - self.emptyLineWidth * 0.5;
    end   = CENTER_Y - radius - self.emptyLineWidth * 0.5 - self.outsideLineWidth;
    [self drawMarkVlaueWithStartX:CENTER_X endX:CENTER_X startY:start endY:end position:@"top"];
}

- (void)drawMarkVlaueWithStartX:(CGFloat)startX
                          endX:(CGFloat)endX
                        startY:(CGFloat)startY
                          endY:(CGFloat)endY
                      position:(NSString *)position {
    
    UIBezierPath *line = [UIBezierPath bezierPath];
    [[UIColor blackColor] set];
    [line moveToPoint:CGPointMake(startX, startY)];
    [line addLineToPoint:CGPointMake(endX, endY)];
    [line setLineWidth:0.5];
    [line stroke];
    
    NSString *valueStr = nil;
    if ([position isEqualToString:@"left"]) {
        
        valueStr = [NSString stringWithFormat:@"%02.0f", (90 - self.progressAngle / 2) / (360.0 - self.progressAngle) * self.targetValue];
        [self drawMarkVlaue:valueStr xPosition:endX yPosition:startY offset:CGPointMake(1, 0.5)];
        
    } else if ([position isEqualToString:@"top"]) {
        
        valueStr = [NSString stringWithFormat:@"%02.0f", (90 + 90 - self.progressAngle / 2) / (360.0 - self.progressAngle) * self.targetValue];
        [self drawMarkVlaue:valueStr xPosition:startX yPosition:endY offset:CGPointMake(0.5, 1)];
        
    } else {
        
        valueStr = [NSString stringWithFormat:@"%02.0f", (180 + 90 - self.progressAngle / 2) / (360.0 - self.progressAngle) * self.targetValue];
        [self drawMarkVlaue:valueStr xPosition:endX yPosition:startY offset:CGPointMake(0, 0.5)];
    }
}

- (void)drawMarkVlaue:(NSString *)valueStr
            xPosition:(CGFloat)x
            yPosition:(CGFloat)y
               offset:(CGPoint)offset {
    
    NSMutableParagraphStyle *textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    textStyle.alignment = NSTextAlignmentCenter;
    UIColor *textColor = [UIColor colorWithRed:241/255.0 green:147/255.0 blue:51/255.0 alpha:1];
    
    NSDictionary *valueFontAttributes = @{NSFontAttributeName:[UIFont boldSystemFontOfSize:14],
                                          NSForegroundColorAttributeName:textColor,
                                          NSParagraphStyleAttributeName:textStyle};
    NSAttributedString *value = [[NSAttributedString alloc] initWithString:valueStr attributes:valueFontAttributes];
    
    NSMutableAttributedString *text = [NSMutableAttributedString new];
    [text appendAttributedString:value];
    CGSize percentSize = [text size];
    
    CGPoint textCenter = CGPointMake(
                                     x - percentSize.width * offset.x,
                                     y - percentSize.height * offset.y
                                    );
    [text drawAtPoint:textCenter];
}

#pragma mark Draw Text

- (void)drawText:(CGSize)rectSize context:(CGContextRef)c {
    
    NSString *valueFontName = self.valueFontName;
    CGFloat valueFontSize = (self.valueFontSize == -1) ? rectSize.height / 5 : self.valueFontSize;
    CGFloat valueDecimalFontSize = self.valueDecimalFontSize == -1 ? valueFontSize : self.valueDecimalFontSize;
    UIColor *valueFontColor = self.valueFontColor;
    
    NSString *formatString = [NSString stringWithFormat:@"%%.%df", (int)self.valueDecimalPlaces];
    NSString *valueStr;
    if (self.countdown) {
        valueStr = [NSString stringWithFormat:formatString, (self.maxValue - self.value)];
    } else {
        valueStr = [NSString stringWithFormat:formatString, self.value];
    }
    
    NSString *unitFontName = self.unitFontName;
    CGFloat unitFontSize = self.unitFontSize == -1 ? rectSize.height/7 : self.unitFontSize;
    NSString *unitString = [NSString stringWithFormat:@"%@", self.unitString];
    
    NSMutableParagraphStyle *textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    textStyle.alignment = NSTextAlignmentLeft;
    
    NSDictionary *valueFontAttributes = @{NSFontAttributeName:[UIFont fontWithName:valueFontName size:valueFontSize],
                                          NSForegroundColorAttributeName:valueFontColor,
                                          NSParagraphStyleAttributeName:textStyle};
    
    NSMutableAttributedString *text = [NSMutableAttributedString new];
    NSAttributedString *value = [[NSAttributedString alloc] initWithString:valueStr attributes:valueFontAttributes];
    [text appendAttributedString:value];
    
    // set the decimal font size
    NSUInteger decimalLocation = [text.string rangeOfString:@"."].location;
    if (decimalLocation != NSNotFound){
        
        NSDictionary *valueDecimalFontAttributes = @{NSFontAttributeName:[UIFont fontWithName:valueFontName size:valueDecimalFontSize],
                                                     NSForegroundColorAttributeName:valueFontColor,
                                                     NSParagraphStyleAttributeName:textStyle};
        NSRange decimalRange = NSMakeRange(decimalLocation, text.length - decimalLocation);
        [text setAttributes:valueDecimalFontAttributes range:decimalRange];
    }
    
    // ad the unit only if specified
    if (self.showUnitString) {
        
        NSDictionary *unitFontAttributes = @{NSFontAttributeName:[UIFont fontWithName:unitFontName size:unitFontSize],
                                             NSForegroundColorAttributeName:valueFontColor,
                                             NSParagraphStyleAttributeName:textStyle};
        
        NSAttributedString *unit = [[NSAttributedString alloc] initWithString:unitString attributes:unitFontAttributes];
        [text appendAttributedString:unit];
    }
    
    CGSize percentSize = [text size];
    CGPoint textCenter = CGPointMake(
                                     rectSize.width / 2 - percentSize.width / 2 + self.valueOffset.x,
                                     rectSize.height / 2 - percentSize.height / 2 + self.valueOffset.y
                                    );
    
    [text drawAtPoint:textCenter];
}

#pragma mark - Override methods to support animations

+ (BOOL)needsDisplayForKey:(NSString *)key {
    
    if ([key isEqualToString:@"value"]) {
        return YES;
    }
    return [super needsDisplayForKey:key];
}

- (id<CAAction> _Nullable)actionForKey:(NSString *)event {
    
    if ([self presentationLayer] != nil) {
        if ([event isEqualToString:@"value"]) {
            id animation = [super actionForKey:@"backgroundColor"];
            
            if (animation == nil || [animation isEqual:[NSNull null]]) {
                [self setNeedsDisplay];
                return [NSNull null];
            }
            [animation setKeyPath:event];
            [animation setFromValue:[self.presentationLayer valueForKey:@"value"]];
            [animation setToValue:nil];
            return animation;
        }
    }
    return [super actionForKey:event];
}

@end


NS_ASSUME_NONNULL_END
